# 트러블슈팅: Redis 직렬화 오류 및 무한 로그인 루프 해결

> **작성일:** 2025-11-27  
> **관련 서비스:** Backend (Redis, Spring Security), Frontend (Axios Interceptor)  
> **키워드:** `RedisSerializationException`, `Java Record`, `Jackson`, `Login Loop`

---

## 1. 🚨 문제 상황 (Problem)

### 증상 (Symptoms)
1.  **대시보드 진입 실패:** 로그인 후 대시보드나 기업 목록 페이지 접근 시, 데이터를 불러오지 못하고 로그인 페이지로 강제 리다이렉트됨.
2.  **무한 루프:** 재로그인을 시도해도 동일한 현상이 반복됨.
3.  **백엔드 에러 로그:** `SerializationException` 발생.

```text
o.s.web.servlet.DispatcherServlet : Failed to complete request: 
org.springframework.data.redis.serializer.SerializationException: Could not read JSON: 
Unexpected token (START_ARRAY), expected VALUE_STRING: need String, Number of Boolean value that contains type id
```


## 2. 🔍 원인 분석 (Root Cause Analysis)

### A. Redis 직렬화 설정 오류 (Serialization Issue)

  * **원인:** `RedisConfig`에서 Jackson의 `DefaultTyping.NON_FINAL` 옵션을 사용함.
    ```java
    // 기존 설정 (문제 발생)
    objectMapper.activateDefaultTyping(ptv, ObjectMapper.DefaultTyping.NON_FINAL);
    ```
  * **문제점:**
      * `NON_FINAL` 옵션은 **final 클래스**에는 타입 정보(`@class`)를 JSON에 저장하지 않음.
      * 프로젝트에서 DTO로 사용 중인 **Java Record**는 불변 객체로, 컴파일 시 자동으로 `final` 클래스가 됨.
      * **결과:** Redis에 저장될 때 타입 정보 없이 순수 JSON으로 저장되었고, 이를 다시 자바 객체로 역직렬화(Deserialize) 할 때 타입을 유추하지 못해 `SerializationException` (500 Error) 발생.

### B. 프론트엔드 튕김 현상 (Security Flow Issue)

  * **원인:** 백엔드에서 500 에러 발생 시 스프링 부트는 자동으로 `/error` 엔드포인트로 포워딩함.
  * **문제점:**
      * `SecurityConfig`에 `/error` 경로에 대한 접근 허용 설정이 없었음 (`anyRequest().authenticated()`에 걸림).
      * **결과:** 서버 내부 오류(500)임에도 불구하고, 시큐리티 필터가 `/error` 접근을 차단하여 **401 Unauthorized** 응답을 반환함.
      * 프론트엔드(`axiosClient.ts`)는 401 응답을 \*\*"토큰 만료"\*\*로 간주하여 로그인 페이지로 강제 이동시킴 (무한 루프의 원인).

-----

## 3\. ✅ 해결 과정 (Solution)

### Step 1: Redis 설정 변경 (`RedisConfig.java`)

Record 타입을 포함한 모든 객체의 타입 정보를 저장하기 위해 `DefaultTyping` 전략을 수정함.

  * **변경 전:** `ObjectMapper.DefaultTyping.NON_FINAL` (Record 제외됨)
  * **변경 후:** `ObjectMapper.DefaultTyping.EVERYTHING` (모든 타입 포함)
      * *Note:* `EVERYTHING`은 Deprecated 되었으나, Java Record 타입을 캐싱하기 위한 가장 확실한 대안이므로 `PolymorphicTypeValidator`와 함께 사용하여 보안성을 확보함.

<!-- end list -->

```java
// 수정된 코드
PolymorphicTypeValidator ptv = BasicPolymorphicTypeValidator.builder()
        .allowIfBaseType(Object.class)
        .build();

// 모든 타입(Record 포함)에 대해 타입 정보를 저장하도록 설정
objectMapper.activateDefaultTyping(ptv, ObjectMapper.DefaultTyping.EVERYTHING);
```

### Step 2: 시큐리티 설정 보완 (`SecurityConfig.java`)

서버 내부 오류 발생 시, 401로 둔갑되지 않고 실제 에러 내용을 클라이언트에 전달할 수 있도록 에러 페이지 접근을 허용함.

```java
.authorizeHttpRequests(auth -> auth
    // ...
    .requestMatchers("/error").permitAll() // [추가] 에러 페이지 접근 허용
    .anyRequest().authenticated()
)
```

### Step 3: Redis 캐시 초기화 (필수)

설정이 변경되었으므로, 기존에 잘못된 포맷(타입 정보 없는 JSON)으로 저장된 데이터를 삭제해야 함.

```bash
docker exec -it company_redis redis-cli flushall
```

-----

## 4\. 💡 결론 및 배운 점 (Lessons Learned)

1.  **Java Record와 Jackson:** \* Record는 `final` 클래스이므로, Jackson의 `NON_FINAL` 설정 사용 시 타입 정보가 누락된다. 캐싱 객체로 Record를 사용할 때는 `EVERYTHING` 전략이나 별도의 MixIn 설정이 필요하다.
2.  **에러 핸들링의 중요성:** \* 시큐리티 설정에서 `/error` 엔드포인트를 열어두지 않으면, 모든 서버 에러가 "인증 실패(401)"로 오인되어 디버깅을 어렵게 만들고 사용자 경험(무한 로그인)을 해칠 수 있다.
3.  **직렬화 포맷 변경 시 캐시 초기화:** \* 객체 직렬화 방식(설정)이 바뀌면 반드시 기존 캐시 데이터를 비워야 `SerializationException`을 방지할 수 있다.

<!-- end list -->

