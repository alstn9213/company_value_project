# 유틸리티(Utility), 헬퍼(Helper), 내부 메서드

코딩 관련 문서나 오픈소스 코드를 보다 보면 **유틸리티 메서드(Utility Method)**, **헬퍼 메서드(Helper Method)**, **내부 메서드(Private Method)**라는 용어가 자주 혼용되는 것을 볼 수 있습니다. 비슷해 보이지만 명확히 다른 목적을 가진 이 세 가지 개념을 정리해 봅니다.

## 1. 한 눈에 보는 핵심 차이

가장 쉬운 구분법은 **"이 메서드를 누가 호출하는가?"**와 **"상태(State)에 의존하는가?"**를 보는 것입니다.

| 구분 | 비유 | 핵심 키워드 | 누가 쓰는가? | 상태(State) 의존성 |
| --- | --- | --- | --- | --- |
| **유틸리티(Utility)** | **공구함** | 범용성, 정적(Static) | **누구나** (프로젝트 전체) | **없음 (Stateless)** |
| **헬퍼(Helper)** | **조수** | 보조, 가독성, 문맥 | **특정 기능/클래스** | **있을 수 있음** (멤버변수 접근 O) |
| **내부(Private)** | **부속품** | 캡슐화, 숨김 | **나 자신** (해당 클래스만) | 상관없음 |

---

## 2. 상세 설명 및 코드 예시

### ① 유틸리티 메서드 (Utility Method)

* **성격:** 프로젝트 **어디서든** 가져다 쓸 수 있는 "공공재"입니다. 특정 비즈니스 로직(정책)과 무관한 순수 계산이나 데이터 가공을 담당합니다.
* **특징:**
* 주로 `static`으로 선언하여 인스턴스 생성 없이 사용합니다.
* **상태를 가지지 않습니다(Stateless).** 오직 파라미터로 받은 입력(`input`)에만 의존하며, 입력이 같으면 항상 같은 출력(`output`)을 보장합니다.


* **예시:** 날짜 포맷 변환, 문자열 자르기, 수학 계산 등.

```java
// [Utility] 어디서든 쓸 수 있는 공구함
public class StringUtils {
    // 인스턴스화 방지
    private StringUtils() {} 

    // 멤버 변수(상태)를 쓰지 않음. 오직 파라미터 str에만 의존.
    public static boolean isEmpty(String str) {
        return str == null || str.trim().isEmpty();
    }
}

```

### ② 헬퍼 메서드 (Helper Method)

* **성격:** 어떤 **"주요 작업"을 도와주는 조수** 역할입니다. 메인 로직이 너무 길어지거나 복잡해질 때, **가독성**을 위해 로직의 일부를 의미 있는 단위로 떼어낸 것입니다.
* **특징:**
* 범용적이지 않고, **특정 문맥(Context)이나 비즈니스 로직** 안에서만 의미가 있습니다.
* 유틸리티와 달리 **클래스의 멤버 변수(상태)를 참조하거나 변경**할 수 있습니다.


* **예시:** `주문()` 메서드 내의 `재고_확인()`, `할인_금액_계산()` 등.

```java
@Service
public class OrderService {
    private final DiscountPolicy discountPolicy; // 상태(의존성)

    public void placeOrder(User user, OrderItem item) {
        // 메인 로직의 가독성을 위해 Helper 메서드 호출
        validateOrder(user, item); 
        
        // ... 주문 생성 로직 ...
    }

    // [Helper] 주문이라는 "문맥"에 종속적이며, 필요하면 멤버 변수 등을 사용함
    private void validateOrder(User user, OrderItem item) {
        if (user.isBlacklist()) {
            throw new OrderException("주문 불가 대상입니다.");
        }
        // ... 기타 검증
    }
}

```

### ③ 내부 메서드 (Internal/Private Method)

* **성격:** **"접근 제어(Visibility)"**의 관점입니다. 클래스 밖에서는 절대 부를 수 없고, 클래스 내부에서만 쓰이는 메서드입니다.
* **특징:**
* 외부에 공개하고 싶지 않은 **구현 상세(Detail)**를 숨길 때(캡슐화) 씁니다.
* 사실상 **대부분의 헬퍼 메서드는 내부(Private) 메서드로 구현**됩니다.



---

## 3. 관계 정리 (벤 다이어그램처럼 생각하기)

사람들이 헷갈리는 이유는 개념들의 **교집합** 때문입니다.

1. **Helper이자 Private인 경우 (가장 흔함):**
* 특정 클래스의 복잡한 로직을 돕기 위해 만들었고(`Helper`), 굳이 밖에서 알 필요가 없어서 `private`으로 막아둔 경우(`Internal`).


2. **Public Helper인 경우:**
* 다른 클래스에서도 이 "도우미" 기능이 필요해서 `public`으로 열어둔 경우입니다. 유틸리티와 비슷해 보이지만, **특정 비즈니스 로직에 종속적**이라면 여전히 헬퍼(Helper Class 등)라고 부릅니다.



---

## 4. 결론: 어떻게 구분해서 써야 할까?

이름을 지을 때(`Util` vs `Helper`)나 코드를 리팩토링할 때 아래 질문을 던져보세요.

* **"이 코드를 다른 패키지, 다른 프로젝트에 가져가도 수정 없이 쓸 수 있나?"**
* 👉 **Utility** (별도 클래스로 분리, 예: `DateUtils`, `Math`)


* **"이 코드는 지금 작성 중인 메인 로직이 너무 길어서 잘라낸 것인가?"**
* 👉 **Helper** (주로 `private` 메서드로 생성, 문맥에 종속적)


* **"이 코드는 외부에서 직접 호출하면 위험하거나 굳이 알 필요가 없는가?"**
* 👉 **Internal/Private**



이 개념들이 섞여서 쓰이는 것은 자연스러운 현상이니, 너무 칼같이 구분하려 스트레스받지 않으셔도 됩니다. 다만, **"범용성(Utility)이냐, 특정 문맥의 보조(Helper)냐"**만 구분해도 코드의 응집도가 높아지고 설계가 훨씬 깔끔해질 것입니다.